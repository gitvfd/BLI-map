// Generated by CoffeeScript 1.6.3
(function() {
  var $, COUNTRY_NAMES, DATA_BY_EL, DATA_BY_INDICATOR, DEBUG, DEFAULT_TITLE, DEFAULT_UNIT, SIZE_L, SIZE_M, SIZE_S, SIZE_XL, adjustToDimensions, assignCountryMarkClasses, attachClick, attachHover, attachPointAnnotation, attachTip, cleanData, collide, createSVG, createTitle, getYearString, log, parseYears, pretty, renderDiagram, renderMap, renderProportional, renderRanking, renderTable, renderTimeSeries, renderTimeSeriesMultiples, setSizeClass, toggleCountrySelection, tooltipHtml,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.DEFAULT_YEARS = [2005, 2006, 2007, 2008, 2009, 2010, 2011];

  DEBUG = false;

  SIZE_XL = 3;

  SIZE_L = 2;

  SIZE_M = 1;

  SIZE_S = 0;

  $ = jQuery;

  log = function() {
    var arg, args, _i, _len, _results;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (DEBUG) {
      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        arg = args[_i];
        _results.push(typeof console !== "undefined" && console !== null ? console.log(arg) : void 0);
      }
      return _results;
    }
  };

  DATA_BY_INDICATOR = {};

  DATA_BY_EL = {};

  DEFAULT_TITLE = {};

  DEFAULT_UNIT = {};

  COUNTRY_NAMES = {};

  $.fn.extend({
    renderDiagram: function(dataLoaded, changedAttribute) {
      var doRender,
        _this = this;
      $(this).html("<i class=\"icon-spinner icon-spin\"></i>");
      doRender = function(isFreshData, changedAttribute) {
        return _this.each(function() {
          var $el, byline, countries, data, hideOtherCountries, indicatorID, newDataRequired, proportional, s, showOecdAverage, subtitle, svg, title, type, x, years, _i, _len, _ref, _ref1;
          $el = $(this);
          type = $el.attr("data-type");
          title = $el.attr("title");
          subtitle = $el.attr("data-subtitle");
          byline = $el.attr("data-byline");
          years = $el.attr("data-years");
          indicatorID = $el.attr("data-indicatorID");
          proportional = $el.attr("data-proportional") === "true";
          showOecdAverage = $el.attr("data-showOecdAverage") === "true";
          hideOtherCountries = $el.attr("data-hideOtherCountries") === "true";
          countries = ((_ref = $el.attr("data-countries")) != null ? _ref.split(",") : void 0) || [];
          years = parseYears(years);
          newDataRequired = isFreshData || (changedAttribute === "data-years" || changedAttribute === "data-indicatorID" || changedAttribute === "data-countries" || changedAttribute === "data-hideOtherCountries");
          if (newDataRequired) {
            log("create new dataset");
            data = (_.find(DATA_BY_INDICATOR, function(x) {
              return x.key === indicatorID;
            })).values.slice();
            _ref1 = cleanData(data, years, countries, hideOtherCountries, showOecdAverage), data = _ref1[0], years = _ref1[1];
            if (countries == null) {
              countries = [];
            }
            countries = _.filter(countries, function(x) {
              return _.find(data, function(y) {
                return y.countryCode === x;
              });
            });
            $el.data("data-cache", data);
          } else {
            data = $el.data("data-cache");
          }
          if (title == null) {
            title = DEFAULT_TITLE[indicatorID];
          }
          if (subtitle == null) {
            subtitle = DEFAULT_UNIT[indicatorID] + ", " + getYearString(years);
          }
          if ($el.hasClass("indicator-main-chart")) {
            $("#num-selected-countries").html("" + (countries != null ? countries.length : "0"));
            s = "";
            $("#country-selector-list input").attr("checked", false);
            for (_i = 0, _len = countries.length; _i < _len; _i++) {
              x = countries[_i];
              s += "<li><a data-country='" + x + "'>" + COUNTRY_NAMES[x] + "</a></li>";
              $("#country-selector-list input[data-countrycode='" + x + "']").attr("checked", "checked");
            }
            $("#selected-countries").html(s);
          }
          $el.addClass("chart");
          $el.empty();
          svg = createSVG($el);
          renderDiagram(svg, type, $el, data, title, subtitle, byline, years, countries, showOecdAverage, proportional, hideOtherCountries);
          if (!$el.hasClass("no-auto-update")) {
            if ($el.hasClass("indicator-main-chart")) {
              return $el.watch(["width", "data-showOecdAverage", "data-proportional", "data-type", "data-byline", "data-years", "data-indicatorID", "data-countries", "data-hideOtherCountries"], function(changedAttribute) {
                return $el.renderDiagram(true, changedAttribute);
              });
            } else {
              return $el.watch(["width", "data-countries"], function(changedAttribute) {
                return $el.renderDiagram(true, changedAttribute);
              });
            }
          }
        });
      };
      if (dataLoaded) {
        return doRender(false, changedAttribute);
      } else {
        return $.when($.getJSON("data/unemployment.json"), $.getJSON("data/country-coords.json"), $.getJSON("data/world-110m.json")).done(function(data, countries, map) {
          var x, _i, _len;
          window.DATA = data[0];
          window.COUNTRIES = countries[0];
          window.MAP_DATA = map[0];
          DATA_BY_INDICATOR = d3.nest().key(function(d) {
            return d.indicatorCode;
          }).entries(window.DATA);
          _.each(DATA_BY_INDICATOR, function(x) {
            DEFAULT_TITLE[x.key] = x.values[0].indicator;
            return DEFAULT_UNIT[x.key] = x.values[0].dataUnit;
          });
          for (_i = 0, _len = DATA.length; _i < _len; _i++) {
            x = DATA[_i];
            COUNTRY_NAMES[x.code] = x.country;
          }
          return doRender(true);
        });
      }
    }
  });

  renderDiagram = function(svg, type, $el, data, title, subtitle, byline, years, countries, showOecdAverage, proportional) {
    var size;
    log("+ + + ");
    log("render chart " + [type, $el, title, years, countries, showOecdAverage, proportional]);
    size = adjustToDimensions($el);
    createTitle($el, svg, title, subtitle, byline, size, years);
    if (size === SIZE_S && !(countries != null ? countries.length : void 0)) {
      showOecdAverage = true;
      countries = ["OTO"];
    }
    if (!showOecdAverage) {
      data = _.filter(data, function(x) {
        return x.countryCode !== "OTO";
      });
    }
    if (type === "table") {
      renderTable($el, svg, data, title, years, countries, showOecdAverage, size);
    } else if (type === "map") {
      return renderMap($el, svg, data, title, years, countries, showOecdAverage, size);
    } else if (proportional) {
      return renderProportional($el, svg, data, title, years, countries, showOecdAverage, size);
    } else if ((years != null ? years.length : void 0) === 1) {
      return renderRanking($el, svg, data, title, years, countries, showOecdAverage, size);
    } else {
      if ((countries != null ? countries.length : void 0) < 4) {
        return renderTimeSeries($el, svg, data, title, years, countries, showOecdAverage, size);
      } else {
        return renderTimeSeriesMultiples($el, svg, data, title, years, countries, showOecdAverage, size);
      }
    }
  };

  createSVG = function($el) {
    return d3.select($el[0]).append('svg');
  };

  createTitle = function($el, svg, title, subtitle, byline, size, years) {
    $el.find(".header").remove();
    $el.find(".footer").remove();
    if ($("body").hasClass("embed")) {
      if (size > SIZE_M) {
        $el.append("<span id=\"logo\">Explore the data on <a href=\"index.html\" target=\"_parent\">data.oecd.org</a></span>");
      } else {
        $el.append("<span id=\"logo\"></span>");
      }
    }
    if ($el.hasClass("indicator-main-chart")) {
      $("#chart-title").html("" + title);
      $("#chart-subtitle").html("" + subtitle);
      $("#chart-byline").html("" + byline);
    } else if (size > SIZE_M) {
      $el.prepend("<div class='header'>\n	<div class=\"title\">" + title + "</div>\n	<div class=\"subtitle\">" + subtitle + "</div>\n						\n	<div class=\"chart-button-panel\">\n		<div class='info-btn'><i class=\"icon-ddp-info\"></i>&nbsp;</div>\n		<div class='fullscreen-btn' title='view fullscreen'><i class=\"icon-ddp-fullscreen\"></i>&nbsp;</div>\n		<div class='share-btn' title='share this chart' ><i class=\"icon-ddp-share\"></i>&nbsp;</div>\n	</div>\n	<!-- <div class=\"byline\">" + byline + "</div> -->\n</div>");
      $el.find(".info-btn").qtip({
        content: "" + title + "<br/>" + byline,
        style: {
          classes: 'qtip-tipsy info-tip'
        },
        position: {
          my: "bottom right",
          at: "top center",
          viewport: $(document)
        }
      });
    } else if (size === SIZE_M) {
      $el.prepend("<div class='year-title'>" + (getYearString(years)) + "</div>");
      $el.prepend("<div class='header'>\n	<div class=\"title\">" + title + "</div>\n	<div class=\"chart-button-panel\">\n		<div class='info-btn'><i class=\"icon-ddp-info\"></i>&nbsp;</div>\n		<div class='fullscreen-btn' title='view fullscreen'><i class=\"icon-ddp-fullscreen\"></i>&nbsp;</div>\n		<div class='share-btn' title='share this chart'><i class=\"icon-ddp-share\"></i>&nbsp;</div>\n	\n	</div>\n</div>");
      $el.find(".info-btn").qtip({
        content: "" + title + "<br/>" + subtitle + "<br/>" + byline,
        style: {
          classes: 'qtip-tipsy info-tip'
        },
        position: {
          my: "bottom right",
          at: "top center",
          viewport: $(document)
        }
      });
    }
    $el.find(".fullscreen-btn").qtip({
      content: true,
      style: {
        classes: 'qtip-tipsy info-tip'
      },
      position: {
        my: "bottom right",
        at: "top center",
        viewport: $(document)
      }
    });
    return $el.find(".share-btn").qtip({
      content: true,
      style: {
        classes: 'qtip-tipsy info-tip'
      },
      position: {
        my: "bottom right",
        at: "top center",
        viewport: $(document)
      }
    });
  };

  adjustToDimensions = function($el, w, h) {
    var size;
    w = $el.width();
    h = $el.height();
    if (w > 480 && h > 250) {
      size = w > 800 ? SIZE_XL : SIZE_L;
      setSizeClass($el, "fullSize " + (w > 800 ? "xl" : void 0));
      $el.find("svg").css({
        "width": w,
        "height": w / 2
      });
    } else if (w > 160) {
      size = SIZE_M;
      setSizeClass($el, "mediumSize");
      $el.find("svg").css({
        "width": w,
        "height": w / 2
      });
    } else {
      size = SIZE_S;
      $el.css({
        "width": w,
        "height": 40
      });
      setSizeClass($el, "smallSize");
    }
    return size;
  };

  pretty = function(value) {
    return "" + ((value * 100).toFixed(1)) + "%";
  };

  parseYears = function(years) {
    var a, _i, _ref, _ref1, _results;
    if ((years != null ? years.indexOf("-") : void 0) > -1) {
      a = years.split("-");
      return (function() {
        _results = [];
        for (var _i = _ref = Number(a[0]), _ref1 = Number(a[1]); _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; _ref <= _ref1 ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this);
    } else if ((years != null ? years.indexOf(",") : void 0) > -1) {
      return years.split(",");
    } else if (Number(years)) {
      return [Number(years)];
    } else {
      return window.DEFAULT_YEARS;
    }
  };

  getYearString = function(a) {
    if (!(a != null ? a.length : void 0)) {
      return "";
    }
    if (a.length === 1) {
      return a[0];
    }
    return "" + a[0] + "-" + a[a.length - 1];
  };

  attachPointAnnotation = function(selection, my, at, xx, yy) {
    if (my == null) {
      my = 'bottom right';
    }
    if (at == null) {
      at = 'top center';
    }
    if (xx == null) {
      xx = 0;
    }
    if (yy == null) {
      yy = 0;
    }
    this.each(function() {
      return $(this).qtip({
        content: true,
        position: {
          my: my,
          at: at,
          adjust: {
            x: xx,
            y: xx
          },
          viewport: $(document)
        },
        style: {
          classes: "qtip-tipsy"
        },
        show: {
          event: false,
          ready: true
        },
        hide: false
      }).show();
    });
    return this;
  };

  attachTip = function(selection, target, my, at, xx, yy) {
    if (my == null) {
      my = 'bottom right';
    }
    if (at == null) {
      at = 'top center';
    }
    if (xx == null) {
      xx = 0;
    }
    if (yy == null) {
      yy = 0;
    }
    this.each(function() {
      return $(this).qtip({
        id: "hover-tip",
        content: true,
        position: {
          my: my,
          at: at,
          target: target,
          viewport: $(document),
          adjust: {
            x: xx,
            y: yy
          }
        },
        style: {
          classes: 'qtip-tipsy'
        }
      });
    });
    return this;
  };

  attachHover = function(selection, $el) {
    return selection.on("mouseover", function() {
      return d3.select(this).classed("highlight", true);
    }).on("mouseout", function() {
      return d3.select(this).classed("highlight", d3.select(this).classed("annotated"));
    });
  };

  attachClick = function(selection, $el, accessor) {
    return selection.on("click", function(d) {
      log("click", d, typeof accessor === "function" ? accessor(d) : void 0);
      if (accessor != null) {
        d = accessor(d);
      }
      return toggleCountrySelection($el, d.countryCode);
    });
  };

  cleanData = function(_data, years, countries, hideOtherCountries) {
    var countryCode, d, dict, i, index, x, y, yearIndex, _i, _j, _len, _len1;
    dict = {};
    yearIndex = {};
    years = _.filter(years, function(x) {
      return _.find(_data, function(d) {
        return d.year === x;
      });
    });
    for (i = _i = 0, _len = years.length; _i < _len; i = ++_i) {
      y = years[i];
      yearIndex[y] = i;
    }
    for (_j = 0, _len1 = _data.length; _j < _len1; _j++) {
      d = _data[_j];
      countryCode = d.code;
      if (hideOtherCountries && (!(__indexOf.call(countries, countryCode) >= 0)) && countryCode !== "OTO") {
        continue;
      }
      if (!dict[countryCode]) {
        dict[countryCode] = {
          "country": d.country,
          "countryCode": d.code,
          "isOECDAverage": d.code === "OTO",
          "values": []
        };
      }
      index = yearIndex[d.year];
      if (index != null) {
        dict[countryCode].values[index] = d.value / 100.0;
      }
    }
    _data = (function() {
      var _results;
      _results = [];
      for (x in dict) {
        _results.push(dict[x]);
      }
      return _results;
    })();
    _data = _.filter(_data, function(x) {
      var _k, _len2;
      for (i = _k = 0, _len2 = years.length; _k < _len2; i = ++_k) {
        y = years[i];
        if (x.values[i] == null) {
          return false;
        }
      }
      return true;
    });
    return [_data, years];
  };

  setSizeClass = function($el, className) {
    $el.removeClass("fullSize");
    $el.removeClass("mediumSize");
    $el.removeClass("smallSize");
    $el.removeClass("xl");
    return $el.addClass(className);
  };

  collide = function(node) {
    var nx1, nx2, ny1, ny2, r;
    r = node.radius + 16;
    nx1 = node.x - r;
    nx2 = node.x + r;
    ny1 = node.y - r;
    ny2 = node.y + r;
    return function(quad, x1, y1, x2, y2) {
      var l, x, y;
      if (quad.point && quad.point !== node) {
        x = node.x - quad.point.x;
        y = node.y - quad.point.y;
        l = Math.sqrt(x * x + y * y);
        r = node.radius + quad.point.radius;
        if (l < r) {
          l = (l - r) / l * .5;
          node.x -= x *= l;
          node.y -= y *= l;
          quad.point.x += x;
          quad.point.y += y;
        }
      }
      return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
    };
  };

  toggleCountrySelection = function($el, countryCode) {
    var selectedCountries, _ref;
    selectedCountries = (_ref = $el.attr("data-countries")) != null ? _ref.split(",") : void 0;
    if (selectedCountries == null) {
      selectedCountries = [];
    }
    if (__indexOf.call(selectedCountries, countryCode) >= 0) {
      selectedCountries = _.without(selectedCountries, countryCode);
    } else {
      selectedCountries.push(countryCode);
    }
    return $el.attr("data-countries", selectedCountries.join(","));
  };

  assignCountryMarkClasses = function(selection, highlightedCountries, showOecdAverage, dataF, isHighlighted) {
    var highlightCounter;
    if (dataF == null) {
      dataF = function(x) {
        return x;
      };
    }
    if (isHighlighted == null) {
      isHighlighted = function(d, i) {
        var _ref;
        return (_ref = dataF(d).countryCode, __indexOf.call(highlightedCountries, _ref) >= 0) || (showOecdAverage && dataF(d).countryCode === "OTO");
      };
    }
    highlightCounter = 0;
    return selection.attr("class", function(d, i) {
      if (isHighlighted(d) && dataF(d).countryCode !== "OTO") {
        return "highlight-" + (++highlightCounter);
      }
    }).classed("countryMark", true).classed("oecdAverage", function(d, i) {
      return dataF(d).isOECDAverage;
    }).classed("highlight annotated", isHighlighted).attr("title", function(d, i) {
      return dataF(d).country;
    });
  };

  renderMap = function($el, svg, data, indicator, years, countries, showOecdAverage, size) {
    var NUM_ITERATIONS, a, allValues, bg, c, circle, countryShapes, d, dataLayer, equalSize, globalMax, globalMin, graticule, h, i, map, n, num, o, path, projection, q, radius, scale, value, valueScale, w, x, y, _countries, _i, _j, _len, _ref;
    log("renderMap");
    $el.addClass("map");
    w = $el.find("svg").width();
    h = $el.find("svg").height();
    allValues = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        a = data[_i];
        _results.push(a.values[0]);
      }
      return _results;
    })();
    globalMin = d3.min(allValues);
    globalMax = d3.max(allValues);
    valueScale = d3.scale.linear().domain([0, globalMax]).nice().range([0, Math.max(15, Math.sqrt(w) / 1.5)]);
    equalSize = $el.attr("data-equalSize") === "true";
    scale = Math.min(w / 600, h / 300);
    projection = d3.geo.robinson().translate([w / 2.4, h / 2 + scale * 20]).scale(120 * scale);
    path = d3.geo.path().projection(projection);
    graticule = d3.geo.graticule();
    bg = svg.append("rect").classed("chartBg", true).attr({
      width: w,
      height: h
    });
    map = svg.append("g").classed("worldmap", true);
    "map.append(\"path\")\n	.datum(graticule) \n	.classed(\"graticule\", true) \n	.attr(\"d\", path)\n\nmap.append(\"path\")\n	.datum(graticule.outline)\n	.classed(\"graticule outline\", true)\n	.attr(\"d\", path)";
    countryShapes = topojson.object(window.MAP_DATA, window.MAP_DATA.objects.countries).geometries;
    map.selectAll(".country").data(countryShapes).enter().insert("path", ".graticule").classed("country", true).attr("d", path);
    dataLayer = svg.append("g").classed("mapDataLayer", true);
    _countries = [];
    _ref = window.COUNTRIES.features;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      d = _ref[i];
      o = data.filter(function(x) {
        return d.id === x.country;
      });
      if (o != null ? o.length : void 0) {
        value = o[0].values[0] || o[0].values[1];
        if (equalSize) {
          radius = w / 100;
        } else {
          radius = Math.max(.33, scale) * (valueScale(value) + 1);
        }
        x = projection(d.geometry.coordinates)[0];
        y = projection(d.geometry.coordinates)[1];
        _countries.push({
          label: d.id,
          country: d.id,
          countryCode: o[0].countryCode,
          isOECDAverage: o[0].isOECDAverage,
          targetX: x,
          targetY: y,
          value: value,
          radius: radius,
          x: x,
          y: y,
          data: o
        });
      }
    }
    NUM_ITERATIONS = 50;
    for (num = _j = NUM_ITERATIONS; NUM_ITERATIONS <= 0 ? _j <= 0 : _j >= 0; num = NUM_ITERATIONS <= 0 ? ++_j : --_j) {
      q = d3.geom.quadtree(_countries);
      i = 0;
      n = _countries.length;
      while (++i < n) {
        c = _countries[i];
        c.x += (c.targetX - c.x) * .1 * (num / NUM_ITERATIONS);
        c.y += (c.targetY - c.y) * .1 * (num / NUM_ITERATIONS);
        q.visit(collide(c));
      }
    }
    c = dataLayer.selectAll("g.countryMark").data(_countries).enter().append("g").call(assignCountryMarkClasses, countries, showOecdAverage).attr("transform", function(d, i) {
      return "translate(" + d.x + "," + d.y + ")";
    }).attr("title", function(d, i) {
      return tooltipHtml(d.country, pretty(d.value));
    });
    circle = c.append("circle").attr("r", function(d, i) {
      return d.radius - scale;
    });
    c.call(attachTip);
    c.call(attachHover, $el);
    c.call(attachClick, $el);
    if (size > SIZE_M) {
      c.filter(function(d, i) {
        var _ref1;
        return (_ref1 = d.countryCode, __indexOf.call(countries, _ref1) >= 0) && d.countryCode !== "OTO";
      }).call(attachPointAnnotation, "bottom right", "top center");
      c.filter(function(d, i) {
        return d.countryCode === "OTO";
      }).selectAll("circle").attr("r", 0).attr("title", function(d, i) {
        return tooltipHtml(d.country, pretty(d.value));
      }).call(attachPointAnnotation, "center center", "center center");
    }
    if (size === SIZE_XL) {
      return c.append("text").text(function(d, i) {
        if (d.radius > 15) {
          return pretty(d.value);
        } else {
          return "";
        }
      }).attr("text-anchor", "middle").attr("y", 3);
    }
  };

  tooltipHtml = function(label, value) {
    var s;
    s = "";
    if (label != null) {
      s += "<span class='countryLabel'>" + label + "</span><br/>";
    }
    if (value != null) {
      s += "<span class='number'>" + value + "</span>";
    }
    return s;
  };

  renderTable = function($el, svg, data, indicator, years, countries, showOecdAverage, size) {
    var $t, $tb, $th, $tr, h, highlightCounter, isHighlighted, w, x, y, _i, _j, _len, _len1, _results;
    log("renderTable");
    $el.find("svg").remove();
    $el.empty();
    $el.addClass("table");
    w = $el.width();
    h = $el.height();
    isHighlighted = function(x) {
      var _ref;
      return _ref = x.countryCode, __indexOf.call(countries, _ref) >= 0;
    };
    data.sort(function(a, b) {
      if (isHighlighted(a) && !isHighlighted(b)) {
        return -1;
      }
      if (isHighlighted(b) && !isHighlighted(a)) {
        return 1;
      }
      if (a.country > b.country) {
        return 1;
      }
      if (a.country < b.country) {
        return -1;
      }
      return 0;
    });
    $t = $("<table></table>").appendTo($el);
    $th = $("<thead><tr></tr></thead>").appendTo($t);
    $tb = $("<tbody></tbody>").appendTo($t);
    $th.append("<th>" + "" + "</th>");
    for (_i = 0, _len = years.length; _i < _len; _i++) {
      y = years[_i];
      $th.append("<th>" + y + "</th>");
    }
    highlightCounter = 1;
    _results = [];
    for (_j = 0, _len1 = data.length; _j < _len1; _j++) {
      x = data[_j];
      if (isHighlighted(x)) {
        $tr = $("<tr class='highlight-" + (highlightCounter++) + "'></tr>").appendTo($tb);
      } else {
        $tr = $("<tr></tr>").appendTo($tb);
      }
      $("<th class=''>" + x.country + "</th>").appendTo($tr);
      _results.push((function() {
        var _k, _len2, _ref, _results1;
        _ref = x.values;
        _results1 = [];
        for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
          y = _ref[_k];
          _results1.push($tr.append("<td>" + (pretty(y)) + "</td>"));
        }
        return _results1;
      })());
    }
    return _results;
  };

  renderTimeSeries = function($el, svg, data, indicator, years, countries, showOecdAverage, size) {
    var a, allValues, bg, chart, chartAreaHeight, chartAreaWidth, circles, count, countryMark, dataDots, globalMax, globalMin, h, i, isHighlighted, line, lines, mode, numHighlighted, paddingBottom, paddingLeft, paddingRight, paddingTop, rangeBand, val, valueScale, w, ww, x, xAxis, xAxisG, yAxis, yearScale, _i, _j, _len, _len1, _ref;
    log("renderTimeSeries " + years + " " + size);
    isHighlighted = function(d, i) {
      var _ref;
      return (_ref = d.countryCode, __indexOf.call(countries, _ref) >= 0) || (showOecdAverage && d.countryCode === "OTO");
    };
    numHighlighted = _.filter(data, isHighlighted).length;
    data.sort(function(a, b) {
      if (isHighlighted(a) && !isHighlighted(b)) {
        return 1;
      }
      if (isHighlighted(b) && !isHighlighted(a)) {
        return -1;
      }
      return b.values[b.values.length - 1] - a.values[a.values.length - 1];
    });
    allValues = [];
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      a = data[_i];
      _ref = a.values;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        val = _ref[_j];
        allValues.push(val);
      }
    }
    globalMin = d3.min(allValues);
    globalMax = d3.max(allValues);
    w = $el.find("svg").width();
    h = $el.find("svg").height();
    if (years.length < 4) {
      mode = "slopegraph";
    } else {
      mode = "linechart";
    }
    if (size >= SIZE_L) {
      paddingRight = 0;
      paddingBottom = 40;
      paddingTop = 0;
      paddingLeft = 40;
      if (mode === "slopegraph") {
        paddingRight = paddingLeft = w / 3;
      }
    } else if (size === SIZE_M) {
      paddingRight = 5;
      paddingBottom = 0;
      paddingTop = 0;
      paddingLeft = 36;
    } else {
      paddingRight = 0;
      paddingBottom = 0;
      paddingTop = 0;
      paddingLeft = 0;
    }
    chartAreaWidth = w - paddingRight - paddingLeft;
    chartAreaHeight = h - paddingBottom - paddingTop;
    bg = svg.append("rect").classed("chartBg", true);
    bg.attr({
      width: w,
      height: chartAreaHeight
    }).attr("transform", "translate(" + 0 + ", " + paddingTop + ")");
    valueScale = d3.scale.linear().domain([0, globalMax * 1.2]).nice().range([chartAreaHeight, 0]);
    ww = chartAreaWidth;
    if (size > 1 && mode !== "slopegraph") {
      ww -= 20;
    }
    rangeBand = ww / (years.length - 1);
    yearScale = d3.scale.ordinal().domain(years).range((function() {
      var _k, _len2, _results;
      _results = [];
      for (i = _k = 0, _len2 = years.length; _k < _len2; i = ++_k) {
        x = years[i];
        _results.push(i * rangeBand);
      }
      return _results;
    })());
    line = d3.svg.line().x(function(d, i) {
      return yearScale(years[i]);
    }).y(function(d, i) {
      return valueScale(d);
    });
    chart = svg.append("g").classed("lineChart", true).attr("transform", "translate(" + paddingLeft + ", " + paddingTop + ")");
    if (size >= SIZE_L) {
      xAxis = d3.svg.axis().scale(yearScale).tickSize(-5, 0, 0);
      xAxisG = chart.append("g").classed("axisLegend x", true).attr("transform", "translate(0, " + chartAreaHeight + ")").call(xAxis);
      if (years.length > 10) {
        xAxisG.selectAll("text").style("visibility", function(d, i) {
          if ((d % 5) === 0) {
            return "visible";
          } else {
            return "hidden";
          }
        });
      }
    }
    if (size > SIZE_S) {
      yAxis = d3.svg.axis().scale(valueScale).tickSize(-w, 0, 0).ticks(3 + size).orient("left").tickFormat(function(d, i) {
        return "" + (Math.floor(d * 100)) + "%";
      });
      if (mode === "slopegraph") {
        yAxis.tickPadding(-32);
      } else {
        yAxis.tickPadding(-paddingLeft + 12);
      }
      chart.append("g").classed("axisLegend y", true).attr("transform", "translate(" + (-paddingLeft) + ", 0)").call(yAxis);
    }
    countryMark = chart.selectAll('g.countryMark').data(data).enter().append("g").call(assignCountryMarkClasses, countries, showOecdAverage).attr({
      "fullTitle": function(d, i) {
        return tooltipHtml(d.country, pretty(d.values[d.values.length - 1]));
      },
      "leftTitle": function(d, i) {
        return tooltipHtml(null, pretty(d.values[0]));
      },
      "rightTitle": function(d, i) {
        return tooltipHtml(null, pretty(d.values[d.values.length - 1]));
      },
      "countryTitle": function(d, i) {
        return tooltipHtml(d.country);
      }
    });
    lines = countryMark.append("g").attr({
      title: function(d, i) {
        return tooltipHtml(d.country);
      }
    });
    lines.append("path").classed("hoverHelper", true).attr({
      d: function(d, i) {
        return line(d.values);
      }
    });
    lines.append("path").attr({
      d: function(d, i) {
        return line(d.values);
      }
    });
    dataDots = countryMark.selectAll(".dataDot").data(function(d, i) {
      return _.map(d.values, function(x) {
        return {
          value: x,
          country: d.country
        };
      });
    }).enter().append("g").attr("transform", function(d, i) {
      return "translate(" + (yearScale(years[i])) + ", " + (valueScale(d.value)) + ")";
    }).classed("dataDot", true);
    circles = dataDots.append("circle").attr("title", function(d, i) {
      return tooltipHtml("" + d.country + " (" + years[i] + ")", pretty(d.value));
    }).attr("r", function(d, i) {
      return [1.5, 2.5, 3.5, 5][size];
    });
    if (size === SIZE_XL && mode !== "slopegraph") {
      dataDots.append("text").classed("background", true).text(function(d, i) {
        return pretty(d.value);
      }).attr("text-anchor", "middle").attr("y", -10);
      dataDots.append("text").text(function(d, i) {
        return pretty(d.value);
      }).attr("text-anchor", "middle").attr("y", -10);
    }
    lines.call(attachTip, "mouse", null, null, 0, -10);
    circles.call(attachTip, "mouse", null, null, 0, -10);
    countryMark.call(attachClick, $el);
    countryMark.call(attachHover, $el);
    if (size > SIZE_M) {
      count = 0;
      if (mode !== "slopegraph") {
        return countryMark.each(function() {
          var t;
          if (d3.select(this).classed("annotated")) {
            t = d3.select(this).selectAll("circle").filter(function(d, i) {
              return i === years.length - 1;
            }).attr("title", "" + (d3.select(this).attr("fullTitle")));
            if (count === 0) {
              t.call(attachPointAnnotation, "bottom right", "top center");
            } else if (count === numHighlighted - 1) {
              t.call(attachPointAnnotation, "top right", "bottom center");
            } else {
              t.call(attachPointAnnotation, "center left", "center right");
            }
            return count++;
          }
        });
      } else {
        return countryMark.each(function() {
          var leftAnnotation;
          if (d3.select(this).classed("annotated")) {
            leftAnnotation = d3.select(this).selectAll("circle").filter(function(d, i) {
              return i === 0;
            }).attr("title", "" + (d3.select(this).attr("leftTitle"))).call(attachPointAnnotation, "right center", "left center");
            d3.select(this).selectAll("circle").filter(function(d, i) {
              return i === years.length - 1;
            }).attr("title", "" + (d3.select(this).attr("rightTitle"))).call(attachPointAnnotation, "left center", "right center");
            if (years.length === 2) {
              d3.select(this).attr("title", "" + (d3.select(this).attr("countryTitle"))).call(attachPointAnnotation, "center center", "center center");
            } else {

            }
            return count++;
          }
        });
      }
    }
  };

  renderTimeSeriesMultiples = function($el, svg, data, indicator, years, countries, showOecdAverage, size) {
    var a, allValues, cell, cellHeight, cellPadding, cellSpacing, cellWidth, chart, chartAreaHeight, chartAreaWidth, countryMark, globalMax, globalMin, h, i, line, numCols, numRows, paddingBottom, paddingLeft, paddingRight, paddingTop, panelContainer, rangeBand, val, valueScale, w, x, yAxis, yearScale, _i, _j, _len, _len1, _ref;
    log("renderTimeSeriesMultiples");
    data.sort(function(a, b) {
      var _ref, _ref1, _ref2, _ref3;
      if ((_ref = a.countryCode, __indexOf.call(countries, _ref) >= 0) && !(_ref1 = b.countryCode, __indexOf.call(countries, _ref1) >= 0)) {
        return 1;
      }
      if ((_ref2 = b.countryCode, __indexOf.call(countries, _ref2) >= 0) && !(_ref3 = a.countryCode, __indexOf.call(countries, _ref3) >= 0)) {
        return -1;
      }
      return b.values[b.values.length - 1] - a.values[a.values.length - 1];
    });
    allValues = [];
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      a = data[_i];
      _ref = a.values;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        val = _ref[_j];
        allValues.push(val);
      }
    }
    globalMin = d3.min(allValues);
    globalMax = d3.max(allValues);
    w = $el.find("svg").width();
    h = $el.find("svg").height();
    numCols = Math.ceil(Math.sqrt(countries.length));
    numRows = Math.ceil(countries.length / numCols);
    paddingRight = 0;
    paddingBottom = 0;
    paddingTop = 0;
    paddingLeft = 0;
    cellSpacing = 2;
    cellPadding = 10;
    chartAreaWidth = w + cellSpacing - paddingRight - paddingLeft;
    chartAreaHeight = h + cellSpacing - paddingBottom - paddingTop;
    cellWidth = chartAreaWidth / numCols - cellSpacing;
    cellHeight = chartAreaHeight / numRows - cellSpacing;
    valueScale = d3.scale.linear().domain([0, globalMax * 1.2]).nice().range([cellHeight, 0]);
    rangeBand = (cellWidth - cellPadding * 2) / (years.length - 1);
    yearScale = d3.scale.ordinal().domain(years).range((function() {
      var _k, _len2, _results;
      _results = [];
      for (i = _k = 0, _len2 = years.length; _k < _len2; i = ++_k) {
        x = years[i];
        _results.push(cellPadding + i * rangeBand);
      }
      return _results;
    })());
    line = d3.svg.line().x(function(d, i) {
      return yearScale(years[i]);
    }).y(function(d, i) {
      return valueScale(d);
    });
    panelContainer = svg.append("g").attr("transform", "translate(" + paddingLeft + ", " + paddingTop + ")").classed("lineChart", true);
    cell = panelContainer.selectAll(".panel").data(countries).enter().append("g").classed("panel", true).attr("transform", function(d, i) {
      return "translate(" + ((i % numCols) * (cellWidth + cellSpacing)) + ", " + (Math.floor(i / numCols) * (cellHeight + cellSpacing)) + ")";
    });
    cell.append("rect").attr("width", cellWidth).attr("height", cellHeight).classed("chartBg", true);
    yAxis = d3.svg.axis().scale(valueScale).tickSize(-w, 0, 0).ticks(3 + size).orient("left").tickFormat(function(d, i) {
      return "";
    }).tickPadding(-paddingLeft + 12);
    cell.append("g").classed("axisLegend y", true).attr("transform", "translate(" + (-paddingLeft) + ", 0)").call(yAxis);
    cell.append("text").classed("title", true).text(function(d) {
      return (_.find(data, function(x) {
        return x.countryCode === d;
      })).country;
    }).attr("dy", 20).attr("dx", 5);
    chart = cell.append("g").classed("lineChart", true);
    countryMark = chart.selectAll('g.countryMark').data(function(d, i) {
      return _.map(data, function(x) {
        return {
          highlighted: x.countryCode === d || (x.countryCode === "OTO" && showOecdAverage),
          data: x
        };
      });
    }).enter().append("g").call(assignCountryMarkClasses, countries, showOecdAverage, (function(x) {
      return x.data;
    }), (function(x) {
      return x.highlighted;
    })).classed("annotated highlight", function(d) {
      return d.highlighted;
    }).attr("title", function(d, i) {
      return tooltipHtml(d.data.country, pretty(d.data.values[d.data.values.length - 1]));
    });
    countryMark.append("path").style("stroke-width", 10).attr("d", function(d, i) {
      return line(d.data.values);
    }).style("opacity", 0);
    countryMark.append("path").style("stroke-width", 1).attr("d", function(d, i) {
      return line(d.data.values);
    });
    countryMark.call(attachTip, "mouse", null, null, 0, -10);
    countryMark.call(attachClick, $el, function(x) {
      return x.data;
    });
    countryMark.call(attachHover, $el);
    countryMark.selectAll("circle").data(function(d, i) {
      return d.data.values;
    }).enter().append("circle").attr("cx", function(d, i) {
      return yearScale(years[i]);
    }).attr("cy", function(d, i) {
      return valueScale(d);
    }).attr("r", function(d, i) {
      return 3.5;
    });
    return countryMark.filter(function(d, i) {
      return d.highlighted && !d.data.isOECDAverage;
    }).each(function() {
      var t;
      t = d3.select(this).selectAll("circle").filter(function(d, i) {
        return i === years.length - 1;
      }).attr("title", "" + (d3.select(this).attr("oldtitle")));
      return t.call(attachPointAnnotation, "bottom right", "top center");
    });
  };

  renderRanking = function($el, svg, data, indicator, years, countries, showOecdAverage, size) {
    var a, allValues, bg, chart, chartAreaHeight, chartAreaWidth, chartElement, countryMark, globalMax, globalMin, h, hoverMarker, i, mode, paddingBottom, paddingLeft, paddingRight, paddingTop, rangeBand, rankScale, valueAxis, valueLine, valueScale, w, x, _i, _j, _k, _len, _len1, _ref, _ref1, _results;
    log("renderRanking " + years);
    allValues = [];
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      a = data[_i];
      a.values.reverse();
      _ref = a.values;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        x = _ref[_j];
        allValues.push(x);
      }
    }
    globalMin = d3.min(allValues);
    globalMax = d3.max(allValues);
    w = $el.find("svg").width();
    h = $el.find("svg").height();
    mode = w * 1.2 > h ? "horizontal" : "vertical";
    if (size >= SIZE_L) {
      paddingRight = 0;
      paddingBottom = 100;
      paddingTop = 0;
      paddingLeft = 40;
      if (mode === "vertical") {
        paddingRight = 10;
        paddingLeft = 100;
        paddingBottom = 60;
        paddingTop = 50;
      }
    } else if (size === SIZE_M) {
      paddingRight = 6;
      paddingBottom = 0;
      paddingTop = 0;
      paddingLeft = 36;
      if (mode === "vertical") {
        paddingLeft = 120;
        paddingRight = 20;
      }
    } else {
      paddingRight = 0;
      paddingBottom = 0;
      paddingTop = 0;
      paddingLeft = 0;
    }
    chartAreaWidth = w - paddingRight - paddingLeft;
    chartAreaHeight = h - paddingBottom - paddingTop;
    bg = svg.append("rect").classed("chartBg", true);
    bg.attr({
      width: w,
      height: chartAreaHeight
    }).attr("transform", "translate(" + 0 + ", " + paddingTop + ")");
    valueScale = d3.scale.linear().domain([0, globalMax * 1.2]).nice().range([chartAreaHeight, 0]);
    rangeBand = chartAreaWidth / data.length;
    if (size === SIZE_S) {
      rangeBand = 3;
    }
    rankScale = d3.scale.ordinal().domain((function() {
      _results = [];
      for (var _k = 0, _ref1 = data.length; 0 <= _ref1 ? _k <= _ref1 : _k >= _ref1; 0 <= _ref1 ? _k++ : _k--){ _results.push(_k); }
      return _results;
    }).apply(this)).range((function() {
      var _k, _len2, _results;
      _results = [];
      for (i = _k = 0, _len2 = data.length; _k < _len2; i = ++_k) {
        x = data[i];
        _results.push((i + .5) * rangeBand);
      }
      return _results;
    })());
    chart = svg.append("g").classed("rankChart " + mode, true).attr("transform", "translate(" + paddingLeft + ", " + paddingTop + ")");
    if (size > SIZE_S) {
      valueAxis = d3.svg.axis().scale(valueScale).tickSize(-w, 0, 0).ticks(3 + size).orient("left").tickFormat(function(d, i) {
        return "" + (Math.floor(d * 100)) + "%";
      }).tickPadding(-paddingLeft + 12);
      chart.append("g").classed("axisLegend y", true).call(valueAxis).attr("transform", "translate(" + (-paddingLeft) + ",0)");
    }
    data.sort(function(a, b) {
      return -(b.values[0] - a.values[0]);
    });
    countryMark = chart.selectAll('g.countryMark').data(data).enter().append("g").call(assignCountryMarkClasses, countries, showOecdAverage).attr({
      "title": function(d, i) {
        return tooltipHtml("" + d.country + " (" + years[0] + ")", pretty(d.values[0]));
      }
    });
    chartElement = countryMark.append("g").attr({
      "title": function(d, i) {
        return tooltipHtml("" + d.country + " (" + years[0] + ")", pretty(d.values[0]));
      }
    }).classed("chartElement", true);
    countryMark.attr("transform", function(d, i) {
      return "translate(" + (rankScale(i)) + ", " + chartAreaHeight + ")";
    });
    hoverMarker = chartElement.append("line").classed("hoverMarker", true).attr("x1", 0).attr("x2", 0).attr("y1", function(d, i) {
      if (years.length > 1) {
        return valueScale(d.values[1]) - chartAreaHeight;
      } else {
        return 0;
      }
    }).attr("y2", function(d, i) {
      return valueScale(d.values[0]) - chartAreaHeight;
    }).attr({
      "title": function(d, i) {
        return tooltipHtml("" + d.country + " (" + years[0] + ")", pretty(d.values[0]));
      }
    }).style("stroke-width", rangeBand).style("opacity", .0);
    valueLine = chartElement.append("line").attr("x1", 0).attr("x2", 0).attr("y1", function(d, i) {
      if (years.length > 1) {
        return valueScale(d.values[1]) - chartAreaHeight;
      } else {
        return 0;
      }
    }).attr("y2", function(d, i) {
      return valueScale(d.values[0]) - chartAreaHeight;
    }).style("stroke-width", Math.max(2, rangeBand * .66)).attr({
      "title": function(d, i) {
        return tooltipHtml("" + d.country + " (" + years[0] + ")", pretty(d.values[0]));
      }
    });
    if (size > SIZE_S) {
      if (years.length > 1) {
        chartElement.append("circle").classed("comparisonPoint", true).attr("cx", 0).attr("cy", 0).attr("r", 2).attr("transform", function(d, i) {
          return "translate(0, " + (valueScale(d.values[1]) - chartAreaHeight) + ")";
        });
      }
    }
    if (size > SIZE_M) {
      countryMark.append("text").text(function(d, i) {
        return d.country;
      }).attr("text-anchor", "end").attr("transform", function(d, i) {
        return "rotate(-45)translate(-3,10)";
      });
    }
    chartElement.call(attachTip);
    countryMark.call(attachHover, $el);
    chartElement.call(attachClick, $el);
    if (size > SIZE_M) {
      return chart.selectAll("g.highlight").selectAll(".chartElement").call(attachPointAnnotation);
    }
  };

  renderProportional = function($el, svg, data, indicator, years, countries, showOecdAverage, size) {
    var chart, chartAreaHeight, chartAreaWidth, countryMark, h, paddingBottom, paddingLeft, paddingRight, paddingTop, sumValues, treemap, w, x, _i, _j, _len, _len1;
    log("renderProportional " + years + " " + size);
    showOecdAverage = false;
    data = _.filter(data, function(x) {
      return !x.isOECDAvg && x.countryCode !== "EU27";
    });
    sumValues = 0;
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      x = data[_i];
      sumValues += x.values[x.values.length - 1];
    }
    for (_j = 0, _len1 = data.length; _j < _len1; _j++) {
      x = data[_j];
      x.values[x.values.length - 1] /= sumValues;
    }
    data.sort(function(a, b) {
      return a.values[b.values.length - 1] - b.values[a.values.length - 1];
    });
    w = $el.find("svg").width();
    h = $el.find("svg").height();
    if (size >= SIZE_L) {
      paddingRight = 0;
      paddingBottom = 30;
      paddingTop = 0;
      paddingLeft = 0;
    } else if (size === SIZE_M) {
      paddingRight = 1;
      paddingBottom = 1;
      paddingTop = 1;
      paddingLeft = 1;
    } else {
      paddingRight = 0;
      paddingBottom = 0;
      paddingTop = 0;
      paddingLeft = 0;
    }
    chartAreaWidth = w - paddingRight - paddingLeft;
    chartAreaHeight = h - paddingBottom - paddingTop;
    treemap = d3.layout.treemap().size([chartAreaWidth, chartAreaHeight]).value(function(d, i) {
      return d.values[d.values.length - 1];
    }).sort(function(a, b) {
      return a.values[a.values.length - 1] - b.values[b.values.length - 1];
    }).nodes({
      children: data
    });
    chart = svg.append("g").classed("proportionalChart", "true").attr("transform", function(d) {
      return "translate(" + paddingLeft + "," + paddingTop + ")";
    });
    countryMark = chart.selectAll("g.countryMark").data(data).enter().append("g").call(assignCountryMarkClasses, countries, showOecdAverage).attr("title", function(d) {
      return tooltipHtml(d.country, pretty(d.values[d.values.length - 1]));
    }).attr("transform", function(d) {
      return "translate(" + d.x + "," + d.y + ")";
    });
    countryMark.append("rect").attr("width", function(d) {
      return d.dx;
    }).attr("height", function(d) {
      return d.dy;
    }).attr("title", function(d) {
      return tooltipHtml(d.country, pretty(d.values[d.values.length - 1]));
    });
    if (size > SIZE_M) {
      countryMark.filter(function(d, i) {
        return i > 20;
      }).append("text").text(function(d, i) {
        return d.country;
      }).attr({
        dy: 15,
        dx: 4,
        width: function(d, i) {
          return d.dx;
        }
      });
    }
    if (size > SIZE_S) {
      return chart.selectAll("g.highlight").selectAll("rect").call(attachPointAnnotation);
    }
  };

}).call(this);
